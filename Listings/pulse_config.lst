C51 COMPILER V9.54   PULSE_CONFIG                                                          01/10/2018 14:56:36 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE PULSE_CONFIG
OBJECT MODULE PLACED IN .\Objects\pulse_config.obj
COMPILER INVOKED BY: D:\Program Files (x86)\KeiluVision\C51\C51\BIN\C51.EXE pulse_config.c OPTIMIZE(9,SPEED) BROWSE DEBU
                    -G OBJECTEXTEND PRINT(.\Listings\pulse_config.lst) OBJECT(.\Objects\pulse_config.obj)

line level    source

   1          #include "stdafx.h"
   2          //code by </MATRIX>@Neod Anderjon
   3          //==========================================================================
   4          //脉冲配置发生器
   5          
   6          //全局变量声明
   7          u32 ReversalCnt;
   8          u32 SettingSpeedHz;
   9          u32 RotationDistance;
  10          u32 divFreqCnt;
  11          u32 CalDivFreqConst;
  12          u32 ReversalRange;
  13          MotorRunStatus MotorStatusFlag;
  14          MotorRunMode MotorModeFlag;
  15          LineRadSelect lrs_flag;
  16          
  17          //EA寄存器操作
  18          void TimerEnableAllOperate (FunctionStatus flag)
  19          {
  20   1              EA = flag;
  21   1      }
  22          
  23          //TMOD定时器模式寄存器操作
  24          void TimerModeRegisterOperate (char order)
  25          {
  26   1              TMOD = order;
  27   1      }
  28          
  29          //ITx寄存器操作
  30          void TimerInterruptOperate (TimerNumber nbr, FunctionStatus flag)
  31          {
  32   1              if (nbr == Timer0)
  33   1                      IT0 = flag;
  34   1              else if (nbr == Timer1)
  35   1                      IT1 = flag;
  36   1      }
  37          
  38          //ETx寄存器操作
  39          void TimerEnableTimerOperate (TimerNumber nbr, FunctionStatus flag)
  40          {
  41   1              if (nbr == Timer0)
  42   1                      ET0 = flag;
  43   1              else if (nbr == Timer1)
  44   1                      ET1 = flag;
  45   1      }
  46          
  47          //TRx寄存器操作
  48          void TimerTriggerRegisterOperate (TimerNumber nbr, FunctionStatus flag)
  49          {
  50   1              if (nbr == Timer0)
  51   1                      TR0 = flag;
  52   1              else if (nbr == Timer1)
  53   1                      TR1 = flag;
  54   1      }
C51 COMPILER V9.54   PULSE_CONFIG                                                          01/10/2018 14:56:36 PAGE 2   

  55          
  56          //EXx寄存器操作
  57          void TimerExternInterruptOperate (TimerNumber nbr, FunctionStatus flag)
  58          {
  59   1              if (nbr == Timer0)
  60   1                      EX0 = flag;
  61   1              else if (nbr == Timer1)
  62   1                      EX1 = flag;
  63   1      }
  64          
  65          //THx，TLx寄存器操作
  66          void TimerInitValueOperate (TimerNumber nbr, u32 value, TimerBit bt)
  67          {
  68   1              uint32_t hBitValue, lBitValue;
  69   1              
  70   1              switch (bt)
  71   1              {
  72   2              case bit8:              hBitValue = (256 - value); lBitValue = (256 - value);                                   break;
  73   2              case bit13:     hBitValue = (8192 - value) / 256; lBitValue = (8192 - value) % 256;     break;
  74   2              case bit16:     hBitValue = (65536 - value) / 256; lBitValue = (65536 - value) % 256;   break;
  75   2              case bitNone:   hBitValue = value; lBitValue = value;                                                                   break;
  76   2              }
  77   1              if (nbr == Timer0)
  78   1              {
  79   2                      TH0 = hBitValue;
  80   2                      TL0 = lBitValue;
  81   2              }
  82   1              else if (nbr == Timer1)
  83   1              {
  84   2                      TH1 = hBitValue;
  85   2                      TL1 = lBitValue;
  86   2              }
  87   1      }
  88          
  89          //定时器初始配置
  90          void Timer_InitConfig (void)
  91          {
  92   1              /*
  93   1                      定时器0用于脉冲发生器及急停外部中断
  94   1                      定时器1开启外部中断用于红外解码接收
  95   1              */
  96   1              TimerModeRegisterOperate(0x01);         
  97   1              TimerInitValueOperate(Timer0, Timer0Value, bit16);
  98   1              TimerInitValueOperate(Timer1, Timer1Value, bitNone);    
  99   1              TimerEnableAllOperate(Enable);                                  //打开定时器总使能
 100   1              
 101   1              //脉冲发生器
 102   1              TimerInterruptOperate(Timer0, Enable);
 103   1              TimerEnableTimerOperate(Timer0, Enable);                //T0开中断使能
 104   1              TimerTriggerRegisterOperate(Timer0, Disable);   //初始关闭T0
 105   1              TimerExternInterruptOperate(Timer0, Enable);    //打开外部中断0使能
 106   1              
 107   1              //红外解码
 108   1              //T1不使能ET1，只使用外部中断
 109   1              TimerTriggerRegisterOperate(Timer1, Enable);    //打开T1                      
 110   1              TimerInterruptOperate(Timer1, Enable);                  //允许外部中断
 111   1              TimerExternInterruptOperate(Timer1, Enable);    //打开外部中断1使能
 112   1          
 113   1              //设定脉冲使用初值
 114   1              ReversalCnt = 0;
 115   1              SettingSpeedHz = 0;                             
 116   1              RotationDistance = 0;
C51 COMPILER V9.54   PULSE_CONFIG                                                          01/10/2018 14:56:36 PAGE 3   

 117   1              divFreqCnt = 0;
 118   1              CalDivFreqConst = DivFreqMaxRange / SettingSpeedHz - 1u;
 119   1              //初始化行距计算
 120   1              DistanceAlgoUpdate();
 121   1              MotorStatusFlag = Stew;                                                 //默认静置
 122   1              MotorModeFlag = LimitRun;                                               //默认有限运行
 123   1      }
 124          
 125          //电机停止转动
 126          void PulseProduce_Stop (void)
 127          {                                                               
 128   1              TimerTriggerRegisterOperate(Timer0, Disable);   //失能定时器T0     
 129   1              IO_MainPulse = 1;                                                               //脉冲IO口拉高
 130   1              divFreqCnt = 0;
 131   1              ReversalCnt = ReversalRange;
 132   1              MotorStatusFlag = Stew;
 133   1              LEDGroupCtrl(led_0, Off);
 134   1              
 135   1              if (lcd_es == dis_status)
 136   1                      LCD1602_DisplayString(3, ROW1, Stop);   
 137   1      }
 138          
 139          //固有脉冲数自动完成
 140          void PulseProduce_Start(void)                                       
 141          {                               
 142   1              //判断送入值是否有效
 143   1              if (SettingSpeedHz != 0u && RotationDistance != 0u)
 144   1              {
 145   2                      //计数变量初始化清零
 146   2                      divFreqCnt = 0;
 147   2                      ReversalCnt = 0;                                                
 148   2                      //更新判断量，把计算放在中断外面执行
 149   2                      CalDivFreqConst = DivFreqMaxRange / SettingSpeedHz - 1u;
 150   2                      DistanceAlgoUpdate();
 151   2                      LEDGroupCtrl(led_0, On);
 152   2                      MotorStatusFlag = Run;
 153   2                      if (lcd_es == dis_status)
 154   2                              LCD1602_DisplayString(3, ROW1, Start);
 155   2                      //使能T0定时器，脉冲开始处理计数和发送         
 156   2                      TimerTriggerRegisterOperate(Timer0, Enable);                                                    
 157   2              }
 158   1      }
 159          
 160          /*
 161                  定时器0中断服务
 162                  中断内部不要进行计算，51计算会产生不可预估的延时
 163          */
 164          void Timer0Service () interrupt 1
 165          {
 166   1              //TimerInitValueOperate(Timer0, Timer0Value, bit16);//函数不可重入
 167   1              TH0 = (65536 - Timer0Value) / 256;
 168   1              TL0 = (65536 - Timer0Value) % 256;
 169   1              
 170   1              //更新分频系数
 171   1              if (divFreqCnt == CalDivFreqConst)
 172   1          {
 173   2              divFreqCnt = 0;
 174   2              IO_MainPulse = !IO_MainPulse;   
 175   2                      if (ReversalCnt == ReversalRange && MotorModeFlag == LimitRun)
 176   2                      {
 177   3                              //此处进行计算(不管复杂度)会干扰信号频率
 178   3                              TimerTriggerRegisterOperate(Timer0, Disable);   
C51 COMPILER V9.54   PULSE_CONFIG                                                          01/10/2018 14:56:36 PAGE 4   

 179   3                              IO_MainPulse = 1;       
 180   3                              MotorStatusFlag = Stew;
 181   3                      }
 182   2                      ReversalCnt++;  
 183   2          }
 184   1              divFreqCnt++;
 185   1      }
 186          
 187          //外部中断急停(速度比矩阵键盘和红外解码要快很多)
 188          void ExternInt0Service () interrupt 0
 189          {
 190   1              TimerExternInterruptOperate(Timer0, Disable);
 191   1              if (IO_EmeStop == 0)
 192   1              {
 193   2                      delay_ms(10);
 194   2                      if (IO_EmeStop == 0)
 195   2                      {
 196   3                              LEDGroupCtrl(led_1, On);
 197   3                              
 198   3                              /*
 199   3                                      这里和PulseProduce_Stop()内容是一样的
 200   3                                      但是直接调用PulseProduce_Stop()会有函数重入的警告
 201   3                              */
 202   3                              TimerTriggerRegisterOperate(Timer0, Disable);   
 203   3                              IO_MainPulse = 1;                                               //脉冲IO口拉高
 204   3                              divFreqCnt = 0;
 205   3                              ReversalCnt = ReversalRange;
 206   3                              MotorStatusFlag = Stew;
 207   3                              LEDGroupCtrl(led_0, Off);
 208   3                              
 209   3                              while (!IO_EmeStop);                                    //等待释放
 210   3                              delay_ms(50);
 211   3                              LEDGroupCtrl(led_1, Off);
 212   3                      }
 213   2              }
 214   1              TimerExternInterruptOperate(Timer0, Enable);
 215   1      }
 216          
 217          //切换电机运行模式
 218          void MotorRunModeAdjust (void)
 219          {
 220   1              MotorModeFlag = !MotorModeFlag;                                 //两种模式切换简写
 221   1      }
 222          
 223          //切换输入量的度量单位
 224          void LineRadUnitAdjust (void)
 225          {
 226   1              //在status总显示里也需要单独更新
 227   1              switch (lrs_flag)
 228   1              {
 229   2              case RadUnit:   lrs_flag = LineUnit; LCD1602_DisplayString(0, ROW2, RotationMeter); break;
 230   2              case LineUnit:  lrs_flag = RadUnit; LCD1602_DisplayString(0, ROW2, RotationAngle);      break;
 231   2              }
 232   1      }
 233          
 234          //更新行距计算
 235          void DistanceAlgoUpdate (void)
 236          {
 237   1              switch (lrs_flag)
 238   1              {
 239   2              case RadUnit:   ReversalRange = 2 * RadUnitConst * RotationDistance - 1u;       break;
 240   2              case LineUnit:  ReversalRange = 2 * LineUnitConst * RotationDistance - 1u;      break;
C51 COMPILER V9.54   PULSE_CONFIG                                                          01/10/2018 14:56:36 PAGE 5   

 241   2              }
 242   1      }
 243          
 244          //更换差值
 245          u32 DValueSetting (void)
 246          {
 247   1              u32 dvalue;
 248   1              
 249   1              switch (lrs_flag)
 250   1              {
 251   2              case RadUnit:   dvalue = 30;    break;  //30度
 252   2              case LineUnit:  dvalue = 5;     break;  //5mm
 253   2              default:                dvalue = 30;    break;  //默认30度
 254   2              }
 255   1              
 256   1              return dvalue;
 257   1      }
 258          
 259          //==========================================================================
 260          //code by </MATRIX>@Neod Anderjon


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    809    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     15       5
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
