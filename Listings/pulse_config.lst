C51 COMPILER V9.54   PULSE_CONFIG                                                          01/10/2018 14:51:19 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE PULSE_CONFIG
OBJECT MODULE PLACED IN .\Objects\pulse_config.obj
COMPILER INVOKED BY: D:\Program Files (x86)\KeiluVision\C51\C51\BIN\C51.EXE pulse_config.c OPTIMIZE(9,SPEED) BROWSE DEBU
                    -G OBJECTEXTEND PRINT(.\Listings\pulse_config.lst) OBJECT(.\Objects\pulse_config.obj)

line level    source

   1          #include "stdafx.h"
   2          //code by </MATRIX>@Neod Anderjon
   3          //==========================================================================
   4          //脉冲配置发生器
   5          
   6          //全局变量声明
   7          u32 ReversalCnt;
   8          u32 SettingSpeedHz;
   9          u32 RotationDistance;
  10          u32 divFreqCnt;
  11          u32 CalDivFreqConst;
  12          u32 ReversalRange;
  13          MotorRunStatus MotorStatusFlag;
  14          MotorRunMode MotorModeFlag;
  15          LineRadSelect lrs_flag;
  16          
  17          //EA寄存器操作
  18          void TimerEnableAllOperate (FunctionStatus flag)
  19          {
  20   1              EA = flag;
  21   1      }
  22          
  23          //TMOD定时器模式寄存器操作
  24          void TimerModeRegisterOperate (char order)
  25          {
  26   1              TMOD = order;
  27   1      }
  28          
  29          //ITx寄存器操作
  30          void TimerInterruptOperate (TimerNumber nbr, FunctionStatus flag)
  31          {
  32   1              if (nbr == Timer0)
  33   1                      IT0 = flag;
  34   1              else if (nbr == Timer1)
  35   1                      IT1 = flag;
  36   1      }
  37          
  38          //ETx寄存器操作
  39          void TimerEnableTimerOperate (TimerNumber nbr, FunctionStatus flag)
  40          {
  41   1              if (nbr == Timer0)
  42   1                      ET0 = flag;
  43   1              else if (nbr == Timer1)
  44   1                      ET1 = flag;
  45   1      }
  46          
  47          //TRx寄存器操作
  48          void TimerTriggerRegisterOperate (TimerNumber nbr, FunctionStatus flag)
  49          {
  50   1              if (nbr == Timer0)
  51   1                      TR0 = flag;
  52   1              else if (nbr == Timer1)
  53   1                      TR1 = flag;
  54   1      }
C51 COMPILER V9.54   PULSE_CONFIG                                                          01/10/2018 14:51:19 PAGE 2   

  55          
  56          //EXx寄存器操作
  57          void TimerExternInterruptOperate (TimerNumber nbr, FunctionStatus flag)
  58          {
  59   1              if (nbr == Timer0)
  60   1                      EX0 = flag;
  61   1              else if (nbr == Timer1)
  62   1                      EX1 = flag;
  63   1      }
  64          
  65          //THx，TLx寄存器操作
  66          void TimerInitValueOperate (TimerNumber nbr, u32 value, TimerBit bt)
  67          {
  68   1              uint32_t hBitValue, lBitValue;
  69   1              
  70   1              switch (bt)
  71   1              {
  72   2              case bit8: hBitValue = (256 - value); lBitValue = (256 - value); break;
  73   2              case bit13: hBitValue = (8192 - value) / 256; lBitValue = (8192 - value) % 256; break;
  74   2              case bit16: hBitValue = (65536 - value) / 256; lBitValue = (65536 - value) % 256; break;
  75   2              case bitNone: hBitValue = value; lBitValue = value; break;
  76   2              }
  77   1              if (nbr == Timer0)
  78   1              {
  79   2                      TH0 = hBitValue;
  80   2                      TL0 = lBitValue;
  81   2              }
  82   1              else if (nbr == Timer1)
  83   1              {
  84   2                      TH1 = hBitValue;
  85   2                      TL1 = lBitValue;
  86   2              }
  87   1      }
  88          
  89          //定时器初始配置
  90          void Timer_InitConfig (void)
  91          {
  92   1              /*
  93   1                      定时器0用于脉冲发生器及急停外部中断
  94   1                      定时器1开启外部中断用于红外解码接收
  95   1              */
  96   1              TimerModeRegisterOperate(0x01);         
  97   1              TimerInitValueOperate(Timer0, Timer0Value, bit16);
  98   1              TimerInitValueOperate(Timer1, Timer1Value, bitNone);    
  99   1              TimerEnableAllOperate(Enable);                                  //打开定时器总使能
 100   1              
 101   1              //脉冲发生器
 102   1              TimerInterruptOperate(Timer0, Enable);
 103   1              TimerEnableTimerOperate(Timer0, Enable);                //T0开中断使能
 104   1              TimerTriggerRegisterOperate(Timer0, Disable);   //初始关闭T0
 105   1              TimerExternInterruptOperate(Timer0, Enable);    //打开外部中断0使能
 106   1              
 107   1              //红外解码
 108   1              //T1不使能ET1，只使用外部中断
 109   1              TimerTriggerRegisterOperate(Timer1, Enable);    //打开T1                      
 110   1              TimerInterruptOperate(Timer1, Enable);                  //允许外部中断
 111   1              TimerExternInterruptOperate(Timer1, Enable);    //打开外部中断1使能
 112   1          
 113   1              //设定脉冲使用初值
 114   1              ReversalCnt = 0;
 115   1              SettingSpeedHz = 0;                             
 116   1              RotationDistance = 0;
C51 COMPILER V9.54   PULSE_CONFIG                                                          01/10/2018 14:51:19 PAGE 3   

 117   1              divFreqCnt = 0;
 118   1              CalDivFreqConst = DivFreqMaxRange / SettingSpeedHz - 1u;
 119   1              //初始化行距计算
 120   1              switch (lrs_flag)
 121   1              {
 122   2              case RadUnit: ReversalRange = 2 * RadUnitConst * RotationDistance - 1u; break;
 123   2              case LineUnit: ReversalRange = 2 * LineUnitConst * RotationDistance - 1u; break;
 124   2              }
 125   1              MotorStatusFlag = Stew;                                                 //默认静置
 126   1              MotorModeFlag = LimitRun;                                               //默认有限运行
 127   1      }
 128          
 129          //电机停止转动
 130          void PulseProduce_Stop (void)
 131          {                                                               
 132   1              TimerTriggerRegisterOperate(Timer0, Disable);   //失能定时器T0     
 133   1              IO_MainPulse = 1;                                                               //脉冲IO口拉高
 134   1              divFreqCnt = 0;
 135   1              ReversalCnt = ReversalRange;
 136   1              MotorStatusFlag = Stew;
 137   1              LEDGroupCtrl(led_0, Off);
 138   1              
 139   1              if (lcd_es == dis_status)
 140   1                      LCD1602_DisplayString(3, ROW1, Stop);   
 141   1      }
 142          
 143          //固有脉冲数自动完成
 144          void PulseProduce_Start(void)                                       
 145          {                               
 146   1              //判断送入值是否有效
 147   1              if (SettingSpeedHz != 0u && RotationDistance != 0u)
 148   1              {
 149   2                      //计数变量初始化清零
 150   2                      divFreqCnt = 0;
 151   2                      ReversalCnt = 0;                                                
 152   2                      //更新判断量，把计算放在中断外面执行
 153   2                      CalDivFreqConst = DivFreqMaxRange / SettingSpeedHz - 1u;
 154   2                      //更新行距计算
 155   2                      switch (lrs_flag)
 156   2                      {
 157   3                      case RadUnit: ReversalRange = 2 * RadUnitConst * RotationDistance - 1u; break;
 158   3                      case LineUnit: ReversalRange = 2 * LineUnitConst * RotationDistance - 1u; break;
 159   3                      }
 160   2                      LEDGroupCtrl(led_0, On);
 161   2                      MotorStatusFlag = Run;
 162   2                      if (lcd_es == dis_status)
 163   2                              LCD1602_DisplayString(3, ROW1, Start);
 164   2                      //使能T0定时器，脉冲开始处理计数和发送         
 165   2                      TimerTriggerRegisterOperate(Timer0, Enable);                                                    
 166   2              }
 167   1      }
 168          
 169          /*
 170                  定时器0中断服务
 171                  中断内部不要进行计算，51计算会产生不可预估的延时
 172          */
 173          void Timer0Service () interrupt 1
 174          {
 175   1              //TimerInitValueOperate(Timer0, Timer0Value, bit16);//函数不可重入
 176   1              TH0 = (65536 - Timer0Value) / 256;
 177   1              TL0 = (65536 - Timer0Value) % 256;
 178   1              
C51 COMPILER V9.54   PULSE_CONFIG                                                          01/10/2018 14:51:19 PAGE 4   

 179   1              //更新分频系数
 180   1              if (divFreqCnt == CalDivFreqConst)
 181   1          {
 182   2              divFreqCnt = 0;
 183   2              IO_MainPulse = !IO_MainPulse;   
 184   2                      if (ReversalCnt == ReversalRange && MotorModeFlag == LimitRun)
 185   2                      {
 186   3                              //此处进行计算(不管复杂度)会干扰信号频率
 187   3                              TimerTriggerRegisterOperate(Timer0, Disable);   
 188   3                              IO_MainPulse = 1;       
 189   3                              MotorStatusFlag = Stew;
 190   3                      }
 191   2                      ReversalCnt++;  
 192   2          }
 193   1              divFreqCnt++;
 194   1      }
 195          
 196          //外部中断急停(速度比矩阵键盘和红外解码要快很多)
 197          void ExternInt0Service () interrupt 0
 198          {
 199   1              TimerExternInterruptOperate(Timer0, Disable);
 200   1              if (IO_EmeStop == 0)
 201   1              {
 202   2                      delay_ms(10);
 203   2                      if (IO_EmeStop == 0)
 204   2                      {
 205   3                              LEDGroupCtrl(led_1, On);
 206   3                              
 207   3                              /*
 208   3                                      这里和PulseProduce_Stop()内容是一样的
 209   3                                      但是直接调用PulseProduce_Stop()会有函数重入的警告
 210   3                              */
 211   3                              TimerTriggerRegisterOperate(Timer0, Disable);   
 212   3                              IO_MainPulse = 1;                                               //脉冲IO口拉高
 213   3                              divFreqCnt = 0;
 214   3                              ReversalCnt = ReversalRange;
 215   3                              MotorStatusFlag = Stew;
 216   3                              LEDGroupCtrl(led_0, Off);
 217   3                              
 218   3                              while (!IO_EmeStop);                                    //等待释放
 219   3                              delay_ms(50);
 220   3                              LEDGroupCtrl(led_1, Off);
 221   3                      }
 222   2              }
 223   1              TimerExternInterruptOperate(Timer0, Enable);
 224   1      }
 225          
 226          //切换电机运行模式
 227          void MotorRunModeAdjust (void)
 228          {
 229   1              MotorModeFlag = !MotorModeFlag;                                 //两种模式切换简写
 230   1              
 231   1      //      if (MotorModeFlag == LimitRun)
 232   1      //              MotorModeFlag = UnlimitRun;
 233   1      //      else
 234   1      //              MotorModeFlag = LimitRun;
 235   1      }
 236          
 237          //切换输入量的度量单位
 238          void LineRadUnitAdjust (void)
 239          {
 240   1              switch (lrs_flag)
C51 COMPILER V9.54   PULSE_CONFIG                                                          01/10/2018 14:51:19 PAGE 5   

 241   1              {
 242   2              case RadUnit:   lrs_flag = LineUnit; LCD1602_DisplayString(0, ROW2, RotationMeter); break;
 243   2              case LineUnit:  lrs_flag = RadUnit; LCD1602_DisplayString(0, ROW2, RotationAngle);      break;
 244   2              }
 245   1      }
 246          
 247          //更换差值
 248          u32 DValueSetting (void)
 249          {
 250   1              u32 dvalue;
 251   1              
 252   1              switch (lrs_flag)
 253   1              {
 254   2              case RadUnit:   dvalue = 30;    break;  //30度
 255   2              case LineUnit:  dvalue = 5;     break;  //5mm
 256   2              default:                dvalue = 30;    break;  //默认30度
 257   2              }
 258   1              
 259   1              return dvalue;
 260   1      }
 261          
 262          //==========================================================================
 263          //code by </MATRIX>@Neod Anderjon


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    836    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     15       5
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
